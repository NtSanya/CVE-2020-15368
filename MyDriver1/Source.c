#include <intrin.h>
#include <ntifs.h>
#include <Ntddk.h>
#include <wdm.h>

// important definitions
#include <chonst.h>

#include "proto.h"
#include "NtoskrnlReversedLol.h"
#include "UnstableOffsets.h"

// actual driver shit

#define DBG_LOG(fmt, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[rose][" __FUNCTION__ "] " fmt "\n", ##__VA_ARGS__)

// symbols resolved by pdb parser

__int64 (NTAPI* ExUnlockHandleTableEntry)(__int64 HandleTable, volatile signed __int64* HandleTableEntry) = 0;

PEPROCESS(NTAPI* PsGetNextProcess)(PEPROCESS Process) = 0;

PLDR_DATA_TABLE_ENTRY(NTAPI* MiLookupDataTableEntry)(
    IN  PVOID AddressWithinSection,
    IN  ULONG ResourceHeld
    ) = 0;

// custom process list shit

typedef struct {
    PEPROCESS Process;
    PEPROCESS CreatingProcess;
    BOOLEAN InitialGraceExpired;
    LIST_ENTRY ListEntry;
} MyProcessInfo;

EX_SPIN_LOCK MyProcessInfoListLock;
LIST_ENTRY MyProcessInfoList;

// You need to hold the lock to call this
MyProcessInfo* LookupMyProcessInfo(PEPROCESS Process)
{
    for (LIST_ENTRY* MyListEntry = MyProcessInfoList.Flink; MyListEntry != &MyProcessInfoList; MyListEntry = MyListEntry->Flink)
    {
        MyProcessInfo* myShit = CONTAINING_RECORD(MyListEntry, MyProcessInfo, ListEntry);
        if (myShit->Process == Process)
            return myShit;
    }
    return NULL;
}

// You need to hold the lock to call this
PEPROCESS LookupCreatingProcess(PEPROCESS Process)
{
    KIRQL OriginalIrql = ExAcquireSpinLockExclusive(&MyProcessInfoListLock);
    MyProcessInfo* myShit = LookupMyProcessInfo(Process);
    PEPROCESS CreatingProcess = myShit ? myShit->CreatingProcess : NULL;
    ExReleaseSpinLockExclusive(&MyProcessInfoListLock, OriginalIrql);
    return CreatingProcess;
}

BOOLEAN MyProcessInfoAllowOnce(PEPROCESS Process)
{
    KIRQL OriginalIrql = ExAcquireSpinLockExclusive(&MyProcessInfoListLock);
    MyProcessInfo* myShit = LookupMyProcessInfo(Process);
    BOOLEAN Result = FALSE;
    if (myShit)
    {
        Result = !myShit->InitialGraceExpired;
        myShit->InitialGraceExpired = TRUE;
    }
    ExReleaseSpinLockExclusive(&MyProcessInfoListLock, OriginalIrql);
    return Result;
}

// You need to hold the lock to call this
void FreeMyProcessInfo(MyProcessInfo* myProcessInfo)
{
    RemoveEntryList(&myProcessInfo->ListEntry);
    ObDereferenceObject(myProcessInfo->Process);
    ObDereferenceObject(myProcessInfo->CreatingProcess);
    ExFreePool(myProcessInfo);
}

// You need to hold the lock to call this
MyProcessInfo* CreateMyProcessInfo(PEPROCESS Process, PEPROCESS CreatingProcess)
{
    MyProcessInfo* myShit = ExAllocatePool(NonPagedPool, sizeof(MyProcessInfo));
    if (!myShit)
    {
        DBG_LOG("wtf ExAllocatePool fails");
        __debugbreak();
    }
    RtlZeroMemory(myShit, sizeof(MyProcessInfo));
    DBG_LOG("Process=%p, CreatingProcess=%p", Process, CreatingProcess);
    ObReferenceObject(Process);
    ObReferenceObject(CreatingProcess);
    myShit->Process = Process;
    myShit->CreatingProcess = CreatingProcess;
    myShit->InitialGraceExpired = FALSE;
    InsertHeadList(&MyProcessInfoList, &myShit->ListEntry);
    return myShit;
}

void InitializeMyProcessInfoList()
{
    RtlZeroMemory(&MyProcessInfoListLock, sizeof(MyProcessInfoListLock));
    InitializeListHead(&MyProcessInfoList);
}

void FreeMyProcessInfoList()
{
    KIRQL OriginalIrql = ExAcquireSpinLockExclusive(&MyProcessInfoListLock);
    while (!IsListEmpty(&MyProcessInfoList))
    {
        FreeMyProcessInfo(CONTAINING_RECORD(MyProcessInfoList.Flink, MyProcessInfo, ListEntry));
    }
    ExReleaseSpinLockExclusive(&MyProcessInfoListLock, OriginalIrql);
}

void* MyRegistrationHandle;
void* MyRegistrationContext;

UCHAR Trampoline[] = {
    0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rax, imm64
    0xff, 0xe0 // jmp rax
};

volatile LONG IsUnloading = 0;
PVOID MyCreateProcessNotifyRoutine_Handle = 0;

KDPC myDpc;
KTIMER myTimer;

void MyCreateProcessNotifyRoutine(
    PEPROCESS Process,
    HANDLE ProcessId,
    PPS_CREATE_NOTIFY_INFO CreateInfo
)
{
    if (!CreateInfo)
    {
        DBG_LOG("Process exiting: %p %d (%s)", Process, ProcessId, PsGetProcessImageFileName(Process));

        KIRQL OriginalIrql = ExAcquireSpinLockExclusive(&MyProcessInfoListLock);
        MyProcessInfo* myProcessInfo = LookupMyProcessInfo(Process);
        if (myProcessInfo)
        {
            FreeMyProcessInfo(myProcessInfo);
        }
        else
        {
            DBG_LOG("WTF No process info for exiting process??? %p %d (%s)", Process, ProcessId, PsGetProcessImageFileName(Process));
        }
        ExReleaseSpinLockExclusive(&MyProcessInfoListLock, OriginalIrql);
        return;
    }
    
    DBG_LOG("Process created: %p %d (%s)", Process, ProcessId, PsGetProcessImageFileName(Process));
    HANDLE CreatingProcessId = CreateInfo->CreatingThreadId.UniqueProcess;
    PEPROCESS CreatingProcess;
    DBG_LOG("  Created by: pid %p", CreatingProcessId);
    NTSTATUS Result = PsLookupProcessByProcessId(CreatingProcessId, &CreatingProcess);
    if (Result != STATUS_SUCCESS)
    {
        DBG_LOG("PsLookupProcessByProcessId fails?? ntstatus=%x", Result);
        return;
    }
    DBG_LOG("  Created by: %s, pid %p", PsGetProcessImageFileName(CreatingProcess), CreatingProcessId);

    KIRQL OriginalIrql = ExAcquireSpinLockExclusive(&MyProcessInfoListLock);
    CreateMyProcessInfo(Process, CreatingProcess);
    ExReleaseSpinLockExclusive(&MyProcessInfoListLock, OriginalIrql);

    ObDereferenceObject(CreatingProcess);
}


NTSTATUS MyUnloadRoutine(void* my_start_info)
{
    DBG_LOG("My unload thread runs.");
    LARGE_INTEGER interval;
    interval.QuadPart = -10000 * 100;
    KeDelayExecutionThread(KernelMode, FALSE, &interval);

    DBG_LOG("Now we call ObUnRegisterCallbacks.");
    ObUnRegisterCallbacks(MyRegistrationHandle);

    DBG_LOG("Now we call PsSetCreateProcessNotifyRoutineEx.");
    PsSetCreateProcessNotifyRoutineEx(MyCreateProcessNotifyRoutine_Handle, TRUE);

    DBG_LOG("Now we free all of the MyProcessInfo list entries.");
    FreeMyProcessInfoList();

    DBG_LOG("OK now we cancel all timers.");
    KeCancelTimer(&myTimer);

    DBG_LOG("OK MyUnloadRoutine completes.");
    return STATUS_SUCCESS;
}

BOOLEAN MyEnumHandleProcedure(
    _HANDLE_TABLE* HandleTable,
    PHANDLE_TABLE_ENTRY HandleTableEntry,
    HANDLE Handle,
    PVOID EnumParameter)
{
    PEPROCESS OwningProcess = EnumParameter;

    void* Object = HandleTableEntryToObjectPtr(HandleTableEntry->ObjectPtr);

    //DBG_LOG("Handle %p HandleTableEntry=%p %p Access %x", Handle, HandleTableEntry, Object, HandleTableEntry->GrantedAccess);
    if (!MmIsAddressValid(Object))
        goto exit_func;
    void* ObjectType = ObGetObjectType(Object);
    //DBG_LOG("ObjectType %p", ObjectType);
    if (!MmIsAddressValid(ObjectType))
        goto exit_func;
    UCHAR ObjectTypeIndex = *(UCHAR*)((uintptr_t)ObjectType + OBJECT_TYPE_Index_Offset);
    //DBG_LOG("ObjectTypeIndex %x", ObjectTypeIndex);

    if (ObjectTypeIndex == OBJECT_TYPE_PROCESS_INDEX)
    {
        PEPROCESS kp = (PEPROCESS)Object; // sizeof(_OBJECT_HEADER)
        //DBG_LOG("KPROCESS = %p", kp);
        if (!strcmp(PsGetProcessImageFileName(kp), "notepad.exe"))
        {
            DBG_LOG("Found process %s holding handle to protected process %s", PsGetProcessImageFileName(OwningProcess), PsGetProcessImageFileName(kp));
            DBG_LOG("  Handle: %p HandleTableEntry=%p EPROCESS=%p Access=%x", Handle, HandleTableEntry, Object, HandleTableEntry->GrantedAccess);

            if (HandleTableEntry->GrantedAccess & PROCESS_CREATE_THREAD)
            {
                HandleTableEntry->GrantedAccess &= ~PROCESS_CREATE_THREAD;
                DBG_LOG("  Stripping PROCESS_CREATE_THREAD");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_DUP_HANDLE)
            {
                HandleTableEntry->GrantedAccess &= ~PROCESS_DUP_HANDLE;
                DBG_LOG("  Stripping PROCESS_CREATE_THREAD");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_QUERY_INFORMATION)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_QUERY_INFORMATION);
                DBG_LOG("  Stripping PROCESS_QUERY_INFORMATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_QUERY_LIMITED_INFORMATION)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_QUERY_LIMITED_INFORMATION);
                DBG_LOG("  Stripping PROCESS_QUERY_LIMITED_INFORMATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_VM_READ)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_VM_READ);
                DBG_LOG("  Stripping PROCESS_VM_READ");
            }

            if (
                PsGetProcessId(OwningProcess) == 4 // allow System process to hold a handle
                || !strcmp(PsGetProcessImageFileName(OwningProcess), "csrss.exe") // Allow csrss to hold a handle
                )
            {
                DBG_LOG("  This process is whitelisted; OK");
                goto exit_func;
            }

            if (HandleTableEntry->GrantedAccess & PROCESS_VM_OPERATION)
            {
                HandleTableEntry->GrantedAccess &= ~PROCESS_VM_OPERATION;
                DBG_LOG("  Stripping PROCESS_VM_OPERATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_SET_LIMITED_INFORMATION)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_SET_LIMITED_INFORMATION);
                DBG_LOG("  Stripping PROCESS_SET_LIMITED_INFORMATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_SET_INFORMATION)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_SET_INFORMATION);
                DBG_LOG("  Stripping PROCESS_SET_INFORMATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_VM_WRITE)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_VM_WRITE);
                DBG_LOG("  Stripping PROCESS_VM_READ");
            }
        }
    }

exit_func:;
    //DBG_LOG("Calling ExUnlockHandleTableEntry");
    ExUnlockHandleTableEntry(HandleTable, HandleTableEntry);
    //DBG_LOG("Exiting func");
    return FALSE;
}

void DemoteBadHandles(PEPROCESS kp)
{
    void* objectTable = *(void**)((uintptr_t)kp + EPROCESS_ObjectTable_Offset);
    // DBG_LOG("ObjectTable %p", objectTable);
    if (objectTable)
    {
        if (MmIsAddressValid(objectTable))
        {
            HANDLE Handle;
            ExEnumHandleTable(objectTable, MyEnumHandleProcedure, kp, &Handle);
        }
        else
        {
            DBG_LOG("YOOOOOOOOO FUCK off. Why does this process have a bad object table pointer???");
        }
    }
}

void ScanForHandles()
{
    // Documentation on PsGetNextProcess
    // http://xref.codetector.org/repos/nt5src_XPSP1/-/blob/base/ntos/ps/psenum.c#L111:1

    for (PEPROCESS kp = PsGetNextProcess(NULL); kp; kp = PsGetNextProcess(kp))
    {
        //DBG_LOG("kp = %p", kp);
        //DBG_LOG("Hello %s", PsGetProcessImageFileName(kp));
        HANDLE pid = PsGetProcessId(kp);
        //DBG_LOG("pid %d", pid);
        DemoteBadHandles(kp);
        //DBG_LOG("DemoteBadHandles returns.");
    }
    DBG_LOG("Ok loop complete");
}

NTSTATUS MyLoopThread(void* my_start_info)
{
    while (!IsUnloading)
    {
        ScanForHandles();
        LARGE_INTEGER interval;
        interval.QuadPart = -10000 * 1000;
        KeDelayExecutionThread(KernelMode, FALSE, &interval);
    }
    
    DBG_LOG("Handle stripping thread completes");

    return STATUS_SUCCESS;
}

void UnloadDriver()
{
    // Don't unload multiple times
    if (InterlockedCompareExchange(&IsUnloading, 1, 0) != 0)
    {
        DBG_LOG("Unload already requested.");
        return;
    }

    DBG_LOG("Okay we unload!.");

    HANDLE hThread;
    PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, (PKSTART_ROUTINE)MyUnloadRoutine, NULL);

    // remove patch in Null device

    // jk im lazy
}

void MyDeferredHandleDemotion(KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
    DBG_LOG("My dpc runs! DeferredContext = %p", DeferredContext);
    ScanForHandles();
}

OB_PREOP_CALLBACK_STATUS MyObjPreCallback(
    _In_ PVOID                         RegistrationContext,
    _In_ POB_PRE_OPERATION_INFORMATION OperationInformation
)
{
    if (!OperationInformation->KernelHandle)
    {
        if (OperationInformation->ObjectType == *PsProcessType)
        {
            PEPROCESS SourceProcess = IoGetCurrentProcess();
            PEPROCESS eprocess = OperationInformation->Object;

            char* SrcImageName = PsGetProcessImageFileName(SourceProcess);
            char* ProcessImageName = PsGetProcessImageFileName(eprocess);

            if (strstr(ProcessImageName, "doskey.exe")) {
                DBG_LOG("Unload requested");
                UnloadDriver();
            }

            else if (strstr(ProcessImageName, "notepad.exe")) {
                DBG_LOG("%s tries to touch %s", SrcImageName, ProcessImageName);
                DBG_LOG("You ask for permissions %x", OperationInformation->Parameters->CreateHandleInformation.DesiredAccess);

                ULONG AllowOperation = 0;

                if (!strcmp(SrcImageName, "csrss.exe") || !strcmp(SrcImageName, "lsass.exe"))
                {
                    OperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_QUERY_LIMITED_INFORMATION;
                    DBG_LOG("Ahh fuck it we let csrss do its job... peice of shit");
                    AllowOperation = 1;
                }
                else
                {
                    PEPROCESS CreatingProcess = LookupCreatingProcess(eprocess);
                    if (CreatingProcess)
                    {
                        DBG_LOG("This guy was created by pid %d %s", PsGetProcessId(CreatingProcess), PsGetProcessImageFileName(CreatingProcess));
                        if (CreatingProcess == SourceProcess)
                        {
                            BOOLEAN AllowParentHandleOperation = MyProcessInfoAllowOnce(eprocess);
                            if (AllowParentHandleOperation)
                            {
                                // allow creating process to open handle to the protected process ... for now
                                DBG_LOG("Ok, the parent is allowed for now");
                                // queue a deferred demotion for this handle later after createprocess does its job or whatever
                                LARGE_INTEGER interval = { .QuadPart = -10000 * 50 }; // 50 millis
                                KeSetTimer(&myTimer, interval, &myDpc);
                                AllowOperation = 1;
                            }
                        }
                    }
                    else
                    {
                        DBG_LOG("no process info tracked for %s????", ProcessImageName);
                    }
                }

                if (!AllowOperation)
                {
                    DBG_LOG("You're not allowed so fuck off don't touch my notepad!!!");
                    OperationInformation->Parameters->CreateHandleInformation.DesiredAccess = SYNCHRONIZE | PROCESS_TERMINATE;
                    //    OperationInformation->Parameters->CreateHandleInformation.DesiredAccess =
                    //        SYNCHRONIZE | PROCESS_TERMINATE | PROCESS_SUSPEND_RESUME | PROCESS_CREATE_PROCESS | STANDARD_RIGHTS_REQUIRED | PROCESS_CREATE_THREAD
                    //        | PROCESS_QUERY_LIMITED_INFORMATION | PROCESS_QUERY_INFORMATION | PROCESS_SET_SESSIONID | PROCESS_SET_QUOTA
                    //        | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION;
                }
            }
        }
        if (OperationInformation->ObjectType == *PsThreadType)
        {
            PETHREAD Thread = OperationInformation->Object;
            PEPROCESS Process = PsGetThreadProcess(Thread);
            char* ProcessImageName = PsGetProcessImageFileName(Process);
            if (strstr(ProcessImageName, "notepad.exe")) {
                DBG_LOG("Don't fucking touch my notepad thread asshole!!!");
                OperationInformation->Parameters->CreateHandleInformation.DesiredAccess = SYNCHRONIZE | PROCESS_TERMINATE | PROCESS_SUSPEND_RESUME;
            }
        }
    }

    return OB_PREOP_SUCCESS;
}

PUCHAR PatchLocationVirtual1;
PUCHAR PatchLocationVirtual2;

NTSTATUS SetupTrampolines()
{
    UNICODE_STRING driverName = RTL_CHONSTANT_STRING(L"\\Driver\\Null");
    PDRIVER_OBJECT pDriverObj = NULL;

    NTSTATUS out = ObReferenceObjectByName(
        &driverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        0,
        IoDriverObjectType,
        KernelMode,
        NULL,
        (PVOID*)&pDriverObj);

    DBG_LOG("Null device object at %p. code %x", pDriverObj, out);

    DBG_LOG("Null device at %p", pDriverObj->DriverStart);

    PVOID NullDevTextVirtual = (uintptr_t)pDriverObj->DriverStart + 0x1000; // we will use some empty space in .text for a trampoline

    PLDR_DATA_TABLE_ENTRY Entry = MiLookupDataTableEntry(NullDevTextVirtual, 0);

    if (!Entry)
    {
        DBG_LOG("Wtf? MiLookupDataTableEntry fails");
        return STATUS_UNSUCCESSFUL;
    }

    DBG_LOG("before flags %x", Entry->Flags);

    Entry->Flags |= PLDR_DATA_TABLE_ENTRY_Flags_Signed; // Bypass MmVerifyCallbackFunctionCheckFlags

    DBG_LOG("now flags %x", Entry->Flags);

    PHYSICAL_ADDRESS NullTextPhysical = MmGetPhysicalAddress(NullDevTextVirtual);

    // insert trampoline

    DBG_LOG("null device .text at physical %p", NullTextPhysical);

    PVOID MyMapping = MmMapIoSpace(NullTextPhysical, 0x1000, MmNonCached);
    if (!MyMapping)
    {
        DBG_LOG("WTF? MmMapIoSpace fails");
        return STATUS_UNSUCCESSFUL;
    }

    DBG_LOG("Mapped successfully :)");

    ULONGLONG TrampolineOffset1 = NULL_SYS_TEXT_SECTION_UNUSED_SPACE_OFFSET; // some unused space in .text we can jam our trampoline
    ULONGLONG TrampolineOffset2 = TrampolineOffset1 + sizeof(Trampoline); // some unused space in .text we can jam our trampoline

    PUCHAR PatchLocation1 = (uintptr_t)MyMapping + TrampolineOffset1;
    *(DWORD64*)(Trampoline + 2) = (DWORD64)MyObjPreCallback;
    memcpy(PatchLocation1, Trampoline, sizeof(Trampoline));

    PUCHAR PatchLocation2 = (uintptr_t)MyMapping + TrampolineOffset2;
    *(DWORD64*)(Trampoline + 2) = (DWORD64)MyCreateProcessNotifyRoutine;
    memcpy(PatchLocation2, Trampoline, sizeof(Trampoline));

    DBG_LOG("Patches applied");

    PatchLocationVirtual1 = (uintptr_t)NullDevTextVirtual + TrampolineOffset1;
    PatchLocationVirtual2 = (uintptr_t)NullDevTextVirtual + TrampolineOffset2;

    MmUnmapIoSpace(MyMapping, 0x1000);

    DBG_LOG("Unmapped successfully :)");

    return STATUS_SUCCESS;
}

NTSTATUS DriverEntry(
    MyIrpStruct* my_start_info
    )
{
    DBG_LOG("THIS IS FROM MY MANAUAL MAPPED DRIVER!!!!!!!!!!!1");
    DBG_LOG("Driver base = %p", my_start_info->MappedDriverBase);

    MiLookupDataTableEntry = my_start_info->nt_MiLookupDataTableEntry;
    ExUnlockHandleTableEntry = my_start_info->nt_ExUnlockHandleTableEntry;
    PsGetNextProcess = my_start_info->nt_PsGetNextProcess;
    DBG_LOG("MiLookupDataTableEntry at %p", MiLookupDataTableEntry);

    InitializeMyProcessInfoList();

    KeInitializeDpc(&myDpc, MyDeferredHandleDemotion, NULL);
    KeInitializeTimer(&myTimer);

    if (SetupTrampolines() != STATUS_SUCCESS)
    {
        DBG_LOG("failed to setup trampolines in null.sys");
        return STATUS_UNSUCCESSFUL;
    }

    PVOID MyObjPreCallback_Trampoline = PatchLocationVirtual1;
    PVOID MyCreateProcessNotifyRoutine_Trampoline = PatchLocationVirtual2;
    MyCreateProcessNotifyRoutine_Handle = MyCreateProcessNotifyRoutine_Trampoline;

    UNICODE_STRING MyAltitude;
    RtlInitUnicodeString(&MyAltitude, L"123456");

    OB_OPERATION_REGISTRATION MyOperationRegistration[1];
    MyOperationRegistration[0].ObjectType = PsProcessType;
    MyOperationRegistration[0].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
    MyOperationRegistration[0].PreOperation = MyObjPreCallback_Trampoline;
    MyOperationRegistration[0].PostOperation = NULL;

    OB_CALLBACK_REGISTRATION MyObCallbackInfo;
    MyObCallbackInfo.Version = OB_FLT_REGISTRATION_VERSION;
    MyObCallbackInfo.OperationRegistrationCount = 1;
    MyObCallbackInfo.Altitude = MyAltitude;
    MyObCallbackInfo.RegistrationContext = &MyRegistrationContext;
    MyObCallbackInfo.OperationRegistration = MyOperationRegistration;


    NTSTATUS Result = ObRegisterCallbacks(&MyObCallbackInfo, &MyRegistrationHandle);
    DBG_LOG("ObRegisterCallbacks returns %x", Result);

    //HANDLE hThread;
    //Result = PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, (PKSTART_ROUTINE)MyLoopThread, NULL);
    //DBG_LOG("PsCreateSystemThread returns %x", Result);
    //ZwClose(hThread);

    Result = PsSetCreateProcessNotifyRoutineEx(MyCreateProcessNotifyRoutine_Trampoline, FALSE);
    DBG_LOG("PsSetCreateProcessNotifyRoutineEx returns %x", Result);

    return STATUS_SUCCESS;
}

