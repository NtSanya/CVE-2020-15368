#include <intrin.h>
#include <ntifs.h>
#include <Ntddk.h>
#include <wdm.h>
#include <ntimage.h>

#include "proto.h"
#include "NtoskrnlReversedLol.h"
#include "UnstableOffsets.h"

// CHONST!!!!!!!!
#define chonstexpr constexpr
#define chonst const
#define reinterpret_chast reinterpret_cast

// driver mapper shellcode
__int64 __declspec(dllexport) __fastcall MyIRPHandler(struct _DEVICE_OBJECT* a1, IRP* irp)
{
    ULONG ioctl_no = irp->Tail.Overlay.CurrentStackLocation->Parameters.DeviceIoControl.IoControlCode;
    MyIrpStruct* user_data = (MyIrpStruct*)irp->AssociatedIrp.SystemBuffer;

    void* my_rwx = user_data->nt_ExAllocatePoolWithTag(NonPagedPoolExecute, user_data->payload_size, 'lmao');

    user_data->nt_memcpy(my_rwx, user_data->payload, user_data->payload_size);

    // do relocs
    PIMAGE_DOS_HEADER image = (PIMAGE_DOS_HEADER)my_rwx;
    PIMAGE_NT_HEADERS pe = (PIMAGE_NT_HEADERS)((uintptr_t)my_rwx + image->e_lfanew);
    IMAGE_DATA_DIRECTORY* reloc_dir_info = &pe->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    IMAGE_BASE_RELOCATION* relocs = (IMAGE_BASE_RELOCATION*)((uintptr_t)my_rwx + reloc_dir_info->VirtualAddress);

    uintptr_t basediff = (uintptr_t)my_rwx - pe->OptionalHeader.ImageBase;

    void* relocs_end = (void*)((uintptr_t)relocs + reloc_dir_info->Size);
    while (relocs < relocs_end)
    {
        ULONG va = relocs->VirtualAddress;
        USHORT* entries = (USHORT*)((uintptr_t)relocs + sizeof(IMAGE_BASE_RELOCATION));
        int num_entries = (relocs->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(USHORT);
        for (int i = 0; i < num_entries; i++)
        {
            USHORT entry = entries[i];
            USHORT reloc_type = entry >> 12;
            uintptr_t reloc_offset = (uintptr_t)(entry & 0xfff);
            if (reloc_type == IMAGE_REL_BASED_DIR64)
            {
                ULONG64* reloc_spot = (ULONG64*)((uintptr_t)my_rwx + va + reloc_offset);
                *reloc_spot += basediff;
            }
            else if (reloc_type == IMAGE_REL_BASED_ABSOLUTE)
            {
                // this is padding, skip
            }
            else
            {
                // this should never happen
                __debugbreak();
            }
        }
        relocs = (IMAGE_BASE_RELOCATION*)((uintptr_t)relocs + relocs->SizeOfBlock);
    }

    // allocate start context
    void* my_startcontext = user_data->nt_ExAllocatePoolWithTag(NonPagedPoolExecute, sizeof(MyIrpStruct), 'lmao');
    memcpy(my_startcontext, user_data, sizeof(MyIrpStruct));

    // start thread
    HANDLE hThread;
    ULONG entrypoint_offset = pe->OptionalHeader.AddressOfEntryPoint;
    void* start_addr = (void*)((uintptr_t)my_rwx + (uintptr_t)entrypoint_offset);
    user_data->nt_PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, (PKSTART_ROUTINE)start_addr, my_startcontext);

    ((void (*)(PIRP, CCHAR))user_data->nt_IofCompleteRequest)(irp, 0);

    return 0;
}



// actual driver shit

#define DBG_LOG(fmt, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[rose][" __FUNCTION__ "] " fmt "\n", ##__VA_ARGS__)


typedef struct {
    PEPROCESS Process;
    PEPROCESS CreatingProcess;
    LIST_ENTRY ListEntry;
} MyProcessInfo;

EX_SPIN_LOCK MyProcessInfoListLock;
LIST_ENTRY MyProcessInfoList;

// You need to hold the lock to call this
MyProcessInfo* LookupMyProcessInfo(PEPROCESS Process)
{
    for (LIST_ENTRY* MyListEntry = MyProcessInfoList.Flink; MyListEntry != &MyProcessInfoList; MyListEntry = MyListEntry->Flink)
    {
        MyProcessInfo* myShit = CONTAINING_RECORD(MyListEntry, MyProcessInfo, ListEntry);
        if (myShit->Process == Process)
            return myShit;
    }
    return NULL;
}

// You need to hold the lock to call this
PEPROCESS LookupCreatingProcess(PEPROCESS Process)
{
    KIRQL OriginalIrql = ExAcquireSpinLockExclusive(&MyProcessInfoListLock);
    MyProcessInfo* myShit = LookupMyProcessInfo(Process);
    PEPROCESS CreatingProcess = myShit ? myShit->CreatingProcess : NULL;
    ExReleaseSpinLockExclusive(&MyProcessInfoListLock, OriginalIrql);
    return CreatingProcess;
}

// You need to hold the lock to call this
void FreeMyProcessInfo(MyProcessInfo* myProcessInfo)
{
    RemoveEntryList(&myProcessInfo->ListEntry);
    ObDereferenceObject(myProcessInfo->Process);
    ObDereferenceObject(myProcessInfo->CreatingProcess);
    ExFreePool(myProcessInfo);
}

// You need to hold the lock to call this
MyProcessInfo* CreateMyProcessInfo(PEPROCESS Process, PEPROCESS CreatingProcess)
{
    MyProcessInfo* myShit = ExAllocatePool(NonPagedPool, sizeof(MyProcessInfo));
    if (!myShit)
    {
        DBG_LOG("wtf ExAllocatePool fails");
        __debugbreak();
    }
    DBG_LOG("Process=%p, CreatingProcess=%p", Process, CreatingProcess);
    ObReferenceObject(Process);
    ObReferenceObject(CreatingProcess);
    myShit->Process = Process;
    myShit->CreatingProcess = CreatingProcess;
    InsertHeadList(&MyProcessInfoList, &myShit->ListEntry);
    return myShit;
}

void InitializeMyProcessInfoList()
{
    RtlZeroMemory(&MyProcessInfoListLock, sizeof(MyProcessInfoListLock));
    InitializeListHead(&MyProcessInfoList);
}

void FreeMyProcessInfoList()
{
    KIRQL OriginalIrql = ExAcquireSpinLockExclusive(&MyProcessInfoListLock);
    while (!IsListEmpty(&MyProcessInfoList))
    {
        FreeMyProcessInfo(CONTAINING_RECORD(MyProcessInfoList.Flink, MyProcessInfo, ListEntry));
    }
    ExReleaseSpinLockExclusive(&MyProcessInfoListLock, OriginalIrql);
}

void* MyRegistrationHandle;
void* MyRegistrationContext;

UCHAR Trampoline[] = {
    0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rax, imm64
    0xff, 0xe0 // jmp rax
};

volatile LONG IsUnloading = 0;
PVOID MyCreateProcessNotifyRoutine_Handle = 0;

KDPC myDpc;
KTIMER myTimer;

void MyCreateProcessNotifyRoutine(
    PEPROCESS Process,
    HANDLE ProcessId,
    PPS_CREATE_NOTIFY_INFO CreateInfo
)
{
    if (!CreateInfo)
    {
        DBG_LOG("Process exiting: %p %d (%s)", Process, ProcessId, PsGetProcessImageFileName(Process));

        KIRQL OriginalIrql = ExAcquireSpinLockExclusive(&MyProcessInfoListLock);
        MyProcessInfo* myProcessInfo = LookupMyProcessInfo(Process);
        if (myProcessInfo)
        {
            FreeMyProcessInfo(myProcessInfo);
        }
        else
        {
            DBG_LOG("WTF No process info for exiting process??? %p %d (%s)", Process, ProcessId, PsGetProcessImageFileName(Process));
        }
        ExReleaseSpinLockExclusive(&MyProcessInfoListLock, OriginalIrql);
        return;
    }
    
    DBG_LOG("Process created: %p %d (%s)", Process, ProcessId, PsGetProcessImageFileName(Process));
    HANDLE CreatingProcessId = CreateInfo->CreatingThreadId.UniqueProcess;
    PEPROCESS CreatingProcess;
    DBG_LOG("  Created by: pid %p", CreatingProcessId);
    NTSTATUS Result = PsLookupProcessByProcessId(CreatingProcessId, &CreatingProcess);
    if (Result != STATUS_SUCCESS)
    {
        DBG_LOG("PsLookupProcessByProcessId fails?? ntstatus=%x", Result);
        return;
    }
    DBG_LOG("  Created by: %s, pid %p", PsGetProcessImageFileName(CreatingProcess), CreatingProcessId);

    KIRQL OriginalIrql = ExAcquireSpinLockExclusive(&MyProcessInfoListLock);
    CreateMyProcessInfo(Process, CreatingProcess);
    ExReleaseSpinLockExclusive(&MyProcessInfoListLock, OriginalIrql);

    ObDereferenceObject(CreatingProcess);
}


NTSTATUS MyUnloadRoutine(void* my_start_info)
{
    DBG_LOG("My unload thread runs.");
    LARGE_INTEGER interval;
    interval.QuadPart = -10000 * 100;
    KeDelayExecutionThread(KernelMode, FALSE, &interval);

    DBG_LOG("Now we call ObUnRegisterCallbacks.");
    ObUnRegisterCallbacks(MyRegistrationHandle);

    DBG_LOG("Now we call PsSetCreateProcessNotifyRoutineEx.");
    PsSetCreateProcessNotifyRoutineEx(MyCreateProcessNotifyRoutine_Handle, TRUE);

    DBG_LOG("Now we free all of the MyProcessInfo list entries.");
    FreeMyProcessInfoList();

    DBG_LOG("OK now we cancel all timers.");
    KeCancelTimer(&myTimer);

    DBG_LOG("OK MyUnloadRoutine completes.");
    return STATUS_SUCCESS;
}

__int64 (NTAPI* ExUnlockHandleTableEntry)(__int64 HandleTable, volatile signed __int64* HandleTableEntry) = 0;

BOOLEAN MyEnumHandleProcedure(
    _HANDLE_TABLE* HandleTable,
    PHANDLE_TABLE_ENTRY HandleTableEntry,
    HANDLE Handle,
    PVOID EnumParameter)
{
    PEPROCESS OwningProcess = EnumParameter;

    void* Object = HandleTableEntryToObjectPtr(HandleTableEntry->ObjectPtr);

    //DBG_LOG("Handle %p HandleTableEntry=%p %p Access %x", Handle, HandleTableEntry, Object, HandleTableEntry->GrantedAccess);
    if (!MmIsAddressValid(Object))
        goto exit_func;
    void* ObjectType = ObGetObjectType(Object);
    //DBG_LOG("ObjectType %p", ObjectType);
    if (!MmIsAddressValid(ObjectType))
        goto exit_func;
    UCHAR ObjectTypeIndex = *(UCHAR*)((uintptr_t)ObjectType + OBJECT_TYPE_Index_Offset);
    //DBG_LOG("ObjectTypeIndex %x", ObjectTypeIndex);

    if (ObjectTypeIndex == OBJECT_TYPE_PROCESS_INDEX)
    {
        PEPROCESS kp = (PEPROCESS)Object; // sizeof(_OBJECT_HEADER)
        //DBG_LOG("KPROCESS = %p", kp);
        if (!strcmp(PsGetProcessImageFileName(kp), "notepad.exe"))
        {
            DBG_LOG("Found process %s holding handle to protected process %s", PsGetProcessImageFileName(OwningProcess), PsGetProcessImageFileName(kp));
            DBG_LOG("  Handle: %p HandleTableEntry=%p EPROCESS=%p Access=%x", Handle, HandleTableEntry, Object, HandleTableEntry->GrantedAccess);

            if (HandleTableEntry->GrantedAccess & PROCESS_CREATE_THREAD)
            {
                HandleTableEntry->GrantedAccess &= ~PROCESS_CREATE_THREAD;
                DBG_LOG("  Stripping PROCESS_CREATE_THREAD");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_DUP_HANDLE)
            {
                HandleTableEntry->GrantedAccess &= ~PROCESS_DUP_HANDLE;
                DBG_LOG("  Stripping PROCESS_CREATE_THREAD");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_QUERY_INFORMATION)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_QUERY_INFORMATION);
                DBG_LOG("  Stripping PROCESS_QUERY_INFORMATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_QUERY_LIMITED_INFORMATION)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_QUERY_LIMITED_INFORMATION);
                DBG_LOG("  Stripping PROCESS_QUERY_LIMITED_INFORMATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_VM_READ)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_VM_READ);
                DBG_LOG("  Stripping PROCESS_VM_READ");
            }

            if (
                PsGetProcessId(OwningProcess) == 4 // allow System process to hold a handle
                || !strcmp(PsGetProcessImageFileName(OwningProcess), "csrss.exe") // Allow csrss to hold a handle
                )
            {
                DBG_LOG("  This process is whitelisted; OK");
                goto exit_func;
            }

            if (HandleTableEntry->GrantedAccess & PROCESS_VM_OPERATION)
            {
                HandleTableEntry->GrantedAccess &= ~PROCESS_VM_OPERATION;
                DBG_LOG("  Stripping PROCESS_VM_OPERATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_SET_LIMITED_INFORMATION)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_SET_LIMITED_INFORMATION);
                DBG_LOG("  Stripping PROCESS_SET_LIMITED_INFORMATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_SET_INFORMATION)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_SET_INFORMATION);
                DBG_LOG("  Stripping PROCESS_SET_INFORMATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_VM_WRITE)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_VM_WRITE);
                DBG_LOG("  Stripping PROCESS_VM_READ");
            }
        }
    }

exit_func:;
    //DBG_LOG("Calling ExUnlockHandleTableEntry");
    ExUnlockHandleTableEntry(HandleTable, HandleTableEntry);
    //DBG_LOG("Exiting func");
    return FALSE;
}

void DemoteBadHandles(PEPROCESS kp)
{
    void* objectTable = *(void**)((uintptr_t)kp + EPROCESS_ObjectTable_Offset);
    // DBG_LOG("ObjectTable %p", objectTable);
    if (objectTable)
    {
        HANDLE Handle;
        ExEnumHandleTable(objectTable, MyEnumHandleProcedure, kp, &Handle);
    }
}

void ScanForHandles()
{
    PEPROCESS kp = PsGetCurrentProcess();
    do
    {
        // DBG_LOG("Hello %s", PsGetProcessImageFileName(kp));
        HANDLE pid = PsGetProcessId(kp);
        // DBG_LOG("pid %d", pid);
        if ((__int64)pid > 0) // ????? i dont understand but theres sometimes this negative pid bullshit thats bad haha
        {
            DemoteBadHandles(kp);
        }
        else
        {
            // DBG_LOG("Fuck off this process sucks!!!");
        }

        LIST_ENTRY* list_entry = (uintptr_t)kp + EPROCESS_ActiveProcessLinks_Offset;
        kp = (uintptr_t)list_entry->Flink - EPROCESS_ActiveProcessLinks_Offset;
    } while (kp != PsGetCurrentProcess());
    DBG_LOG("Ok loop complete");
}

NTSTATUS MyLoopThread(void* my_start_info)
{
    while (!IsUnloading)
    {
        ScanForHandles();
        LARGE_INTEGER interval;
        interval.QuadPart = -10000 * 1000;
        KeDelayExecutionThread(KernelMode, FALSE, &interval);
    }
    
    DBG_LOG("Handle stripping thread completes");

    return STATUS_SUCCESS;
}

void UnloadDriver()
{
    // Don't unload multiple times
    if (InterlockedCompareExchange(&IsUnloading, 1, 0) != 0)
    {
        DBG_LOG("Unload already requested.");
        return;
    }

    DBG_LOG("Okay we unload!.");

    HANDLE hThread;
    PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, (PKSTART_ROUTINE)MyUnloadRoutine, NULL);

    // remove patch in Null device

    // jk im lazy
}

void MyDeferredHandleDemotion(KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
    DBG_LOG("My dpc runs! DeferredContext = %p", DeferredContext);
    ScanForHandles();
}

OB_PREOP_CALLBACK_STATUS MyObjPreCallback(
    _In_ PVOID                         RegistrationContext,
    _In_ POB_PRE_OPERATION_INFORMATION OperationInformation
)
{
    if (!OperationInformation->KernelHandle)
    {
        if (OperationInformation->ObjectType == *PsProcessType)
        {
            PEPROCESS SourceProcess = IoGetCurrentProcess();
            PEPROCESS eprocess = OperationInformation->Object;

            char* SrcImageName = PsGetProcessImageFileName(SourceProcess);
            char* ProcessImageName = PsGetProcessImageFileName(eprocess);

            if (strstr(ProcessImageName, "doskey.exe")) {
                DBG_LOG("Unload requested");
                UnloadDriver();
            }

            else if (strstr(ProcessImageName, "notepad.exe")) {
                DBG_LOG("%s tries to touch %s", SrcImageName, ProcessImageName);
                DBG_LOG("You ask for permissions %x", OperationInformation->Parameters->CreateHandleInformation.DesiredAccess);

                PEPROCESS CreatingProcess = LookupCreatingProcess(eprocess);
                if (CreatingProcess)
                {
                    DBG_LOG("This guy was created by pid %d %s", PsGetProcessId(CreatingProcess), PsGetProcessImageFileName(CreatingProcess));
                    if (CreatingProcess == SourceProcess)
                    {
                        // allow creating process to open handle to the protected process ... for now
                        DBG_LOG("Ok, the parent is allowed for now");
                        // queue a deferred demotion for this handle later after createprocess does its job or whatever
                        LARGE_INTEGER interval = { .QuadPart = -10000 * 50 }; // 50 millis
                        KeSetTimer(&myTimer, interval, &myDpc);
                    }
                    else if (!strcmp(SrcImageName, "csrss.exe") || !strcmp(SrcImageName, "lsass.exe"))
                    {
                        OperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_QUERY_LIMITED_INFORMATION;
                        DBG_LOG("Ahh fuck it we let csrss do its job... peice of shit");
                    }
                    else
                    {
                        DBG_LOG("You're not the parent so fuck off don't touch my notepad!!!");
                        OperationInformation->Parameters->CreateHandleInformation.DesiredAccess = SYNCHRONIZE | PROCESS_TERMINATE;
                        //    OperationInformation->Parameters->CreateHandleInformation.DesiredAccess =
                        //        SYNCHRONIZE | PROCESS_TERMINATE | PROCESS_SUSPEND_RESUME | PROCESS_CREATE_PROCESS | STANDARD_RIGHTS_REQUIRED | PROCESS_CREATE_THREAD
                        //        | PROCESS_QUERY_LIMITED_INFORMATION | PROCESS_QUERY_INFORMATION | PROCESS_SET_SESSIONID | PROCESS_SET_QUOTA
                        //        | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION;
                    }
                }
                else
                {
                    DBG_LOG("no process info tracked for %s????", ProcessImageName);
                }
            }
        }
        if (OperationInformation->ObjectType == *PsThreadType)
        {
            PETHREAD Thread = OperationInformation->Object;
            PEPROCESS Process = PsGetThreadProcess(Thread);
            char* ProcessImageName = PsGetProcessImageFileName(Process);
            if (strstr(ProcessImageName, "notepad.exe")) {
                DBG_LOG("Don't fucking touch my notepad thread asshole!!!");
                OperationInformation->Parameters->CreateHandleInformation.DesiredAccess = SYNCHRONIZE | PROCESS_TERMINATE | PROCESS_SUSPEND_RESUME;
            }
        }
    }

    return OB_PREOP_SUCCESS;
}

PLDR_DATA_TABLE_ENTRY (NTAPI *MiLookupDataTableEntry)(
    IN  PVOID AddressWithinSection,
    IN  ULONG ResourceHeld
) = 0;

NTSTATUS DriverEntry(
    MyIrpStruct* my_start_info
    )
{
    DBG_LOG("THIS IS FROM MY MANAUAL MAPPED DRIVER!!!!!!!!!!!1");

    MiLookupDataTableEntry = my_start_info->nt_MiLookupDataTableEntry;
    ExUnlockHandleTableEntry = my_start_info->nt_ExUnlockHandleTableEntry;
    DBG_LOG("MiLookupDataTableEntry at %p", MiLookupDataTableEntry);

    InitializeMyProcessInfoList();

    KeInitializeDpc(&myDpc, MyDeferredHandleDemotion, NULL);
    KeInitializeTimer(&myTimer);

    UNICODE_STRING driverName = RTL_CONSTANT_STRING(L"\\Driver\\Null");
    PDRIVER_OBJECT pDriverObj = NULL;

    NTSTATUS out = ObReferenceObjectByName(
        &driverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        0,
        IoDriverObjectType,
        KernelMode,
        NULL,
        (PVOID*)&pDriverObj);

    DBG_LOG("Null device object at %p. code %x", pDriverObj, out);

    DBG_LOG("Null device at %p", pDriverObj->DriverStart);

    PVOID NullDevTextVirtual = (uintptr_t)pDriverObj->DriverStart + 0x1000; // empty space we can use for trampoline

    PLDR_DATA_TABLE_ENTRY Entry = MiLookupDataTableEntry(NullDevTextVirtual, 0);

    if (!Entry)
    {
        DBG_LOG("Wtf? MiLookupDataTableEntry fails");
        return 0;
    }

    DBG_LOG("before flags %x", Entry->Flags);

    Entry->Flags |= PLDR_DATA_TABLE_ENTRY_Flags_Signed; // Bypass MmVerifyCallbackFunctionCheckFlags

    DBG_LOG("now flags %x", Entry->Flags);

    PHYSICAL_ADDRESS NullTextPhysical = MmGetPhysicalAddress(NullDevTextVirtual);

    // insert trampoline

    DBG_LOG("null device .text at physical %p", NullTextPhysical);

    PVOID MyMapping = MmMapIoSpace(NullTextPhysical, 0x1000, MmNonCached);
    if (!MyMapping)
    {
        DBG_LOG("WTF? MmMapIoSpace fails");
        return STATUS_SUCCESS;
    }

    DBG_LOG("Mapped successfully :)");

    ULONGLONG TrampolineOffset1 = NULL_SYS_TEXT_SECTION_UNUSED_SPACE_OFFSET; // some unused space in .text we can jam our trampoline
    ULONGLONG TrampolineOffset2 = TrampolineOffset1 + sizeof(Trampoline); // some unused space in .text we can jam our trampoline

    PUCHAR PatchLocation1 = (uintptr_t)MyMapping + TrampolineOffset1;
    *(DWORD64*)(Trampoline + 2) = (DWORD64)MyObjPreCallback;
    memcpy(PatchLocation1, Trampoline, sizeof(Trampoline));

    PUCHAR PatchLocation2 = (uintptr_t)MyMapping + TrampolineOffset2;
    *(DWORD64*)(Trampoline + 2) = (DWORD64)MyCreateProcessNotifyRoutine;
    memcpy(PatchLocation2, Trampoline, sizeof(Trampoline));

    DBG_LOG("Patches applied");

    PUCHAR PatchLocationVirtual1 = (uintptr_t)NullDevTextVirtual + TrampolineOffset1;
    PUCHAR PatchLocationVirtual2 = (uintptr_t)NullDevTextVirtual + TrampolineOffset2;

    MmUnmapIoSpace(MyMapping, 0x1000);

    DBG_LOG("Unmapped successfully :)");

    PVOID MyObjPreCallback_Trampoline = PatchLocationVirtual1;
    PVOID MyCreateProcessNotifyRoutine_Trampoline = PatchLocationVirtual2;
    MyCreateProcessNotifyRoutine_Handle = MyCreateProcessNotifyRoutine_Trampoline;

    UNICODE_STRING MyAltitude;
    RtlInitUnicodeString(&MyAltitude, L"123456");

    OB_OPERATION_REGISTRATION MyOperationRegistration[1];
    MyOperationRegistration[0].ObjectType = PsProcessType;
    MyOperationRegistration[0].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
    MyOperationRegistration[0].PreOperation = MyObjPreCallback_Trampoline;
    MyOperationRegistration[0].PostOperation = NULL;

    OB_CALLBACK_REGISTRATION MyObCallbackInfo;
    MyObCallbackInfo.Version = OB_FLT_REGISTRATION_VERSION;
    MyObCallbackInfo.OperationRegistrationCount = 1;
    MyObCallbackInfo.Altitude = MyAltitude;
    MyObCallbackInfo.RegistrationContext = &MyRegistrationContext;
    MyObCallbackInfo.OperationRegistration = MyOperationRegistration;


    NTSTATUS Result = ObRegisterCallbacks(&MyObCallbackInfo, &MyRegistrationHandle);
    DBG_LOG("ObRegisterCallbacks returns %x", Result);

    //HANDLE hThread;
    //Result = PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, (PKSTART_ROUTINE)MyLoopThread, NULL);
    //DBG_LOG("PsCreateSystemThread returns %x", Result);
    //ZwClose(hThread);

    Result = PsSetCreateProcessNotifyRoutineEx(MyCreateProcessNotifyRoutine_Trampoline, FALSE);
    DBG_LOG("PsSetCreateProcessNotifyRoutineEx returns %x", Result);

    return STATUS_SUCCESS;
}

